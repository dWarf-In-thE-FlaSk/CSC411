/*
 */
package ServerClient;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;

/**
 * A class of static methods marshalling and unmarshalling calls from and to a
 * client communicating with the BookingServer.
 * 
 * The structure of a message have to be formatted in the following way:
 * 1. Message type:
 *      0 - request
 *      1 - response
 * 2. Request ID:
 *      Generated by the client and unique for every client but not globally
 * 3. Message:
 *      if request:
 *          1. operation to execute
 *          2. attributes to use in execution
 *      if response:
 *          1. results
 * 
 * @author Rikard Andersson
 */
public class Marshaller {

    public static byte[] marshallResponse(String message, String requestID) {
        // Placeholder function
        return null;
    }
    public static ArrayList<String> unmarshallMessage(byte[] data) {
        // Placeholder function
        return null;
    }
    public static String unmarshallRequestID(byte[] data) {
        // Placeholder function
        return null;
    }
    
    /**
     * Takes an array of commands and their attributes and flattens it to an
     * array of bytes which can be sent as the data element in a DatagramPacket.
     * 
     * @param messageData An array of all the messages and attributes to send to
     * marshall (and later send to the client)
     * @return An array of bytes to send as the data in a DatagramPacket
     */
    public static byte[] marshall(ArrayList<String> messageData) {
        // Using StringBuilder as a more efficient way of building strings as
        // opposed to the operator += or StringBuffer
        StringBuilder marshalledStr = new StringBuilder();
        Iterator<String> listIterator = messageData.iterator();
        
        while(listIterator.hasNext()) {
            
            marshalledStr.append(listIterator.next());
            
            // Appending the delimiter "/" between each object
            if(listIterator.hasNext()) {
                marshalledStr.append("/");
            }
        }
        
        for(String str : messageData) {
            marshalledStr.append(str);
        }
        
        return marshalledStr.toString().getBytes();
    }
    
    /**
     * 
     * @param data array of bytes as extracted from a DatagramPacket and
     * marshalled via a method call from the function above.
     * @return ArrayList of Strings formatted as in class-header
     */
    public static ArrayList<String> unmarshall(byte[] data) {
        String marshalledStr = data.toString(); 

        ArrayList<String> unMarshalledStr = new ArrayList(Arrays.asList(marshalledStr.split("/")));
        
        return unMarshalledStr;
    }
}
